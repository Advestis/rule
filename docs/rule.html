<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ruleskit.rule API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ruleskit.rule</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from abc import ABC
import numpy as np
from typing import Optional
from copy import copy
from .condition import Condition
from .activation import Activation
from .utils import rfunctions as functions


class Rule(ABC):
    def __init__(self, condition: Optional[Condition] = None, activation: Optional[Activation] = None):

        if condition is not None and not isinstance(condition, Condition):
            raise TypeError(&#34;Argument &#39;condition&#39; must derive from Condition or be None.&#34;)
        if activation is not None and not isinstance(activation, Activation):
            raise TypeError(&#34;Argument &#39;activation&#39; must derive from Activation or be None.&#34;)

        self._condition = condition

        self._activation = activation
        self._coverage = None
        self._prediction = None
        self._std = None
        self._criterion = None

    def __and__(self, other: &#34;Rule&#34;) -&gt; &#34;Rule&#34;:
        condition = self._condition + other._condition
        activation = self._activation &amp; other._activation
        return self.__class__(condition, activation)

    def __add__(self, other: &#34;Rule&#34;) -&gt; &#34;Rule&#34;:
        return self &amp; other

    @property
    def condition(self) -&gt; Condition:
        return copy(self._condition)

    @property
    def activation(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Decompress activation vector

        Returns
        -------
        np.ndarray
            of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1]
        &#34;&#34;&#34;
        return self._activation.raw

    @property
    def coverage(self) -&gt; float:
        return self._activation.coverage

    @property
    def prediction(self) -&gt; float:
        return self._prediction

    @property
    def std(self) -&gt; float:
        return self._std

    @property
    def criterion(self) -&gt; float:
        return self._criterion

    def __eq__(self, other) -&gt; bool:
        if not isinstance(other, Rule):
            raise TypeError(f&#34;Can only compare a Rule with another Rule. Tried to compare to {type(other)}.&#34;)
        else:
            return self._condition == other._condition

    def __contains__(self, other: &#34;Rule&#34;) -&gt; bool:
        return other._activation in self._activation

    def __str__(self) -&gt; str:
        prediction = &#34;&lt;prediction unset&gt;&#34;
        if self._prediction is not None:
            prediction = self._prediction
        if self._condition is None:
            return &#34;empty rule&#34;
        return f&#34;If {self._condition.__str__()} Then {prediction}.&#34;

    def __hash__(self) -&gt; hash:
        return hash(self._condition)

    def __len__(self):
        return len(self._condition)

    def evaluate(self, xs: np.ndarray) -&gt; Activation:
        return self._condition.evaluate(xs)

    def fit(self, xs: np.ndarray, y: np.ndarray, crit: str = &#34;mse&#34;):
        &#34;&#34;&#34;Computes activation, prediction, std and criteria of the rule for a given xs and y.&#34;&#34;&#34;
        self.calc_activation(xs)  # returns Activation
        self.calc_prediction(y)
        self.calc_std(y)
        prediction_vector = self.prediction * self.activation
        self.calc_criterion(prediction_vector, y, crit)

    def calc_activation(self, xs: np.ndarray) -&gt; None:
        self._activation = self.evaluate(xs)

    def calc_prediction(self, y: np.ndarray) -&gt; None:
        &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;prediction&#39;&#34;&#34;&#34;
        if self.activation is None:
            raise ValueError(&#34;The activation vector has not been computed yet.&#34;)
        self._prediction = functions.conditional_mean(self.activation, y)

    def calc_std(self, y: np.ndarray) -&gt; None:
        &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;std&#39;&#34;&#34;&#34;
        if self.activation is None:
            raise ValueError(&#34;The activation vector has not been computed yet.&#34;)
        self._std = functions.conditional_std(self.activation, y)

    def calc_criterion(self, p, y, c):
        self._criterion = functions.calc_criterion(p, y, c)

    def predict(self, xs: Optional[np.ndarray] = None) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the prediction vector. If xs is not given, will use existing activation vector.
        Will raise ValueError is xs is None and activation is not yet known.&#34;&#34;&#34;
        if xs is not None:
            self.calc_activation(xs)
        elif self.activation is None:
            raise ValueError(&#34;If the activation vector has not been computed yet, xs can not be None.&#34;)
        return self._prediction * self.activation</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ruleskit.rule.Rule"><code class="flex name class">
<span>class <span class="ident">Rule</span></span>
<span>(</span><span>condition: Union[<a title="ruleskit.condition.Condition" href="condition.html#ruleskit.condition.Condition">Condition</a>, NoneType] = None, activation: Union[<a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a>, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rule(ABC):
    def __init__(self, condition: Optional[Condition] = None, activation: Optional[Activation] = None):

        if condition is not None and not isinstance(condition, Condition):
            raise TypeError(&#34;Argument &#39;condition&#39; must derive from Condition or be None.&#34;)
        if activation is not None and not isinstance(activation, Activation):
            raise TypeError(&#34;Argument &#39;activation&#39; must derive from Activation or be None.&#34;)

        self._condition = condition

        self._activation = activation
        self._coverage = None
        self._prediction = None
        self._std = None
        self._criterion = None

    def __and__(self, other: &#34;Rule&#34;) -&gt; &#34;Rule&#34;:
        condition = self._condition + other._condition
        activation = self._activation &amp; other._activation
        return self.__class__(condition, activation)

    def __add__(self, other: &#34;Rule&#34;) -&gt; &#34;Rule&#34;:
        return self &amp; other

    @property
    def condition(self) -&gt; Condition:
        return copy(self._condition)

    @property
    def activation(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Decompress activation vector

        Returns
        -------
        np.ndarray
            of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1]
        &#34;&#34;&#34;
        return self._activation.raw

    @property
    def coverage(self) -&gt; float:
        return self._activation.coverage

    @property
    def prediction(self) -&gt; float:
        return self._prediction

    @property
    def std(self) -&gt; float:
        return self._std

    @property
    def criterion(self) -&gt; float:
        return self._criterion

    def __eq__(self, other) -&gt; bool:
        if not isinstance(other, Rule):
            raise TypeError(f&#34;Can only compare a Rule with another Rule. Tried to compare to {type(other)}.&#34;)
        else:
            return self._condition == other._condition

    def __contains__(self, other: &#34;Rule&#34;) -&gt; bool:
        return other._activation in self._activation

    def __str__(self) -&gt; str:
        prediction = &#34;&lt;prediction unset&gt;&#34;
        if self._prediction is not None:
            prediction = self._prediction
        if self._condition is None:
            return &#34;empty rule&#34;
        return f&#34;If {self._condition.__str__()} Then {prediction}.&#34;

    def __hash__(self) -&gt; hash:
        return hash(self._condition)

    def __len__(self):
        return len(self._condition)

    def evaluate(self, xs: np.ndarray) -&gt; Activation:
        return self._condition.evaluate(xs)

    def fit(self, xs: np.ndarray, y: np.ndarray, crit: str = &#34;mse&#34;):
        &#34;&#34;&#34;Computes activation, prediction, std and criteria of the rule for a given xs and y.&#34;&#34;&#34;
        self.calc_activation(xs)  # returns Activation
        self.calc_prediction(y)
        self.calc_std(y)
        prediction_vector = self.prediction * self.activation
        self.calc_criterion(prediction_vector, y, crit)

    def calc_activation(self, xs: np.ndarray) -&gt; None:
        self._activation = self.evaluate(xs)

    def calc_prediction(self, y: np.ndarray) -&gt; None:
        &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;prediction&#39;&#34;&#34;&#34;
        if self.activation is None:
            raise ValueError(&#34;The activation vector has not been computed yet.&#34;)
        self._prediction = functions.conditional_mean(self.activation, y)

    def calc_std(self, y: np.ndarray) -&gt; None:
        &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;std&#39;&#34;&#34;&#34;
        if self.activation is None:
            raise ValueError(&#34;The activation vector has not been computed yet.&#34;)
        self._std = functions.conditional_std(self.activation, y)

    def calc_criterion(self, p, y, c):
        self._criterion = functions.calc_criterion(p, y, c)

    def predict(self, xs: Optional[np.ndarray] = None) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the prediction vector. If xs is not given, will use existing activation vector.
        Will raise ValueError is xs is None and activation is not yet known.&#34;&#34;&#34;
        if xs is not None:
            self.calc_activation(xs)
        elif self.activation is None:
            raise ValueError(&#34;If the activation vector has not been computed yet, xs can not be None.&#34;)
        return self._prediction * self.activation</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ruleskit.rule.Rule.activation"><code class="name">var <span class="ident">activation</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Decompress activation vector</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def activation(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Decompress activation vector

    Returns
    -------
    np.ndarray
        of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1]
    &#34;&#34;&#34;
    return self._activation.raw</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.condition"><code class="name">var <span class="ident">condition</span> : <a title="ruleskit.condition.Condition" href="condition.html#ruleskit.condition.Condition">Condition</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def condition(self) -&gt; Condition:
    return copy(self._condition)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.coverage"><code class="name">var <span class="ident">coverage</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coverage(self) -&gt; float:
    return self._activation.coverage</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.criterion"><code class="name">var <span class="ident">criterion</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def criterion(self) -&gt; float:
    return self._criterion</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.prediction"><code class="name">var <span class="ident">prediction</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def prediction(self) -&gt; float:
    return self._prediction</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.std"><code class="name">var <span class="ident">std</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def std(self) -&gt; float:
    return self._std</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ruleskit.rule.Rule.calc_activation"><code class="name flex">
<span>def <span class="ident">calc_activation</span></span>(<span>self, xs: numpy.ndarray) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_activation(self, xs: np.ndarray) -&gt; None:
    self._activation = self.evaluate(xs)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.calc_criterion"><code class="name flex">
<span>def <span class="ident">calc_criterion</span></span>(<span>self, p, y, c)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_criterion(self, p, y, c):
    self._criterion = functions.calc_criterion(p, y, c)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.calc_prediction"><code class="name flex">
<span>def <span class="ident">calc_prediction</span></span>(<span>self, y: numpy.ndarray) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>If you do not need to to all 'fit' but only want to compute 'prediction'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_prediction(self, y: np.ndarray) -&gt; None:
    &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;prediction&#39;&#34;&#34;&#34;
    if self.activation is None:
        raise ValueError(&#34;The activation vector has not been computed yet.&#34;)
    self._prediction = functions.conditional_mean(self.activation, y)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.calc_std"><code class="name flex">
<span>def <span class="ident">calc_std</span></span>(<span>self, y: numpy.ndarray) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>If you do not need to to all 'fit' but only want to compute 'std'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_std(self, y: np.ndarray) -&gt; None:
    &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;std&#39;&#34;&#34;&#34;
    if self.activation is None:
        raise ValueError(&#34;The activation vector has not been computed yet.&#34;)
    self._std = functions.conditional_std(self.activation, y)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, xs: numpy.ndarray) ‑> <a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, xs: np.ndarray) -&gt; Activation:
    return self._condition.evaluate(xs)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, xs: numpy.ndarray, y: numpy.ndarray, crit: str = 'mse')</span>
</code></dt>
<dd>
<div class="desc"><p>Computes activation, prediction, std and criteria of the rule for a given xs and y.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, xs: np.ndarray, y: np.ndarray, crit: str = &#34;mse&#34;):
    &#34;&#34;&#34;Computes activation, prediction, std and criteria of the rule for a given xs and y.&#34;&#34;&#34;
    self.calc_activation(xs)  # returns Activation
    self.calc_prediction(y)
    self.calc_std(y)
    prediction_vector = self.prediction * self.activation
    self.calc_criterion(prediction_vector, y, crit)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, xs: Union[numpy.ndarray, NoneType] = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the prediction vector. If xs is not given, will use existing activation vector.
Will raise ValueError is xs is None and activation is not yet known.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, xs: Optional[np.ndarray] = None) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns the prediction vector. If xs is not given, will use existing activation vector.
    Will raise ValueError is xs is None and activation is not yet known.&#34;&#34;&#34;
    if xs is not None:
        self.calc_activation(xs)
    elif self.activation is None:
        raise ValueError(&#34;If the activation vector has not been computed yet, xs can not be None.&#34;)
    return self._prediction * self.activation</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ruleskit" href="index.html">ruleskit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ruleskit.rule.Rule" href="#ruleskit.rule.Rule">Rule</a></code></h4>
<ul class="two-column">
<li><code><a title="ruleskit.rule.Rule.activation" href="#ruleskit.rule.Rule.activation">activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.calc_activation" href="#ruleskit.rule.Rule.calc_activation">calc_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.calc_criterion" href="#ruleskit.rule.Rule.calc_criterion">calc_criterion</a></code></li>
<li><code><a title="ruleskit.rule.Rule.calc_prediction" href="#ruleskit.rule.Rule.calc_prediction">calc_prediction</a></code></li>
<li><code><a title="ruleskit.rule.Rule.calc_std" href="#ruleskit.rule.Rule.calc_std">calc_std</a></code></li>
<li><code><a title="ruleskit.rule.Rule.condition" href="#ruleskit.rule.Rule.condition">condition</a></code></li>
<li><code><a title="ruleskit.rule.Rule.coverage" href="#ruleskit.rule.Rule.coverage">coverage</a></code></li>
<li><code><a title="ruleskit.rule.Rule.criterion" href="#ruleskit.rule.Rule.criterion">criterion</a></code></li>
<li><code><a title="ruleskit.rule.Rule.evaluate" href="#ruleskit.rule.Rule.evaluate">evaluate</a></code></li>
<li><code><a title="ruleskit.rule.Rule.fit" href="#ruleskit.rule.Rule.fit">fit</a></code></li>
<li><code><a title="ruleskit.rule.Rule.predict" href="#ruleskit.rule.Rule.predict">predict</a></code></li>
<li><code><a title="ruleskit.rule.Rule.prediction" href="#ruleskit.rule.Rule.prediction">prediction</a></code></li>
<li><code><a title="ruleskit.rule.Rule.std" href="#ruleskit.rule.Rule.std">std</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>